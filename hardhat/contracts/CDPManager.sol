pragma solidity >=0.8.0 <0.9.0;

import "hardhat/console.sol";

error CDPManager__HasDebt();

contract CDPManager {
    struct CDP {
        // Total amount of collateral locked in a CDP
        uint256 lockedCollateral; // [wad]
        // Total amount of debt generated by a CDP
        uint256 generatedDebt; // [wad]
    }

    mapping(address => CDP[]) private cdpListPerUser; // Owner => CDP[]
    uint256 private totalSupply;

    constructor() {
        totalSupply=0;
    }

    // Open a new cdp for a given _user address.
    function openCDP(address _user) public payable{
        cdpListPerUser[_user].push(CDP(msg.value, 0));
        totalSupply=totalSupply+msg.value;
    }

    //Adds collateral to an existing CDP
    function transferCollateralToCDP(address _user, uint _cdpIndex)
        public
        payable
    {
        cdpListPerUser[_user][_cdpIndex].lockedCollateral =
            cdpListPerUser[_user][_cdpIndex].lockedCollateral +
            msg.value;
    }


    // Close CDP if you have 0 debt
    function closeCDP(address _user, uint256 _cdpIndex) public {
        if (cdpListPerUser[_user][_cdpIndex].generatedDebt != 0) {
            revert CDPManager__HasDebt();
        }
        (bool sent, ) = payable(msg.sender).call{value: cdpListPerUser[_user][_cdpIndex].lockedCollateral}("");
        if (sent == false) revert();
        totalSupply=totalSupply-cdpListPerUser[_user][_cdpIndex].lockedCollateral;
        cdpListPerUser[_user][_cdpIndex].lockedCollateral=0;
    }

    // View total supply of ether in contract
    function getTotalSupply() view public returns(uint256){
        console.log(totalSupply);
        return totalSupply;
    }

    // View the state of one CDP
    function getOneCDP(address _user,uint256 _cdpIndex) view public returns(CDP memory searchedCDP){
        console.log("CDP LockedCollateral: %d GeneratedDebt: %d",cdpListPerUser[_user][_cdpIndex].lockedCollateral,cdpListPerUser[_user][_cdpIndex].generatedDebt);
        searchedCDP=cdpListPerUser[_user][_cdpIndex];
    }
}
